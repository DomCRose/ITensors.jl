<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ITensor · ITensors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ITensors.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexSetType.html">IndexSet</a></li><li class="is-active"><a class="tocitem" href="ITensorType.html">ITensor</a><ul class="internal"><li><a class="tocitem" href="#Description-1"><span>Description</span></a></li><li><a class="tocitem" href="#Constructors-1"><span>Constructors</span></a></li><li><a class="tocitem" href="#Sparse-constructors-1"><span>Sparse constructors</span></a></li><li><a class="tocitem" href="#Getting-and-setting-elements-1"><span>Getting and setting elements</span></a></li><li><a class="tocitem" href="#Properties-1"><span>Properties</span></a></li><li><a class="tocitem" href="#Priming-and-tagging-1"><span>Priming and tagging</span></a></li><li><a class="tocitem" href="#Index-Manipulations-1"><span>Index Manipulations</span></a></li><li><a class="tocitem" href="#Math-operations-1"><span>Math operations</span></a></li><li><a class="tocitem" href="#Decompositions-1"><span>Decompositions</span></a></li><li><a class="tocitem" href="#Operations-1"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="DMRG.html">DMRG</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/master/docs/src/ITensorType.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ITensor-1"><a class="docs-heading-anchor" href="#ITensor-1">ITensor</a><a class="docs-heading-anchor-permalink" href="#ITensor-1" title="Permalink"></a></h1><h2 id="Description-1"><a class="docs-heading-anchor" href="#Description-1">Description</a><a class="docs-heading-anchor-permalink" href="#Description-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor" href="#ITensors.ITensor"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor&#39;s indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L2-L10">source</a></section></article><h2 id="Constructors-1"><a class="docs-heading-anchor" href="#Constructors-1">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{IndexSet}" href="#ITensors.ITensor-Tuple{IndexSet}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor(inds::IndexSet)
ITensor(inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices given by  the indices <code>inds</code> and element type <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{UndefInitializer,IndexSet}" href="#ITensors.ITensor-Tuple{UndefInitializer,IndexSet}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor(::UndefInitializer,
        inds::IndexSet)
ITensor(::UndefInitializer,
        inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices  <code>inds</code> and element type <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}" href="#ITensors.ITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor(::Type{ElT &lt;: Number}, inds::IndexSet)
ITensor(::Type{ElT &lt;: Number}, inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices <code>inds</code> and  element type <code>ElT</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{#s46} where #s46&lt;:Number,UndefInitializer,IndexSet}" href="#ITensors.ITensor-Tuple{Type{#s46} where #s46&lt;:Number,UndefInitializer,IndexSet}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor(::Type{ElT &lt;: Number},
        ::UndefInitializer,
        inds::IndexSet)
ITensor(::Type{ElT &lt;: Number},
        ::UndefInitializer,
        inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices  <code>inds</code> and element type <code>ElT</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L199-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.randomITensor-Tuple{IndexSet}" href="#ITensors.randomITensor-Tuple{IndexSet}"><code>ITensors.randomITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomITensor(inds::IndexSet)
randomITensor(inds::Index...)</code></pre><p>Construct an ITensor with type <code>Float64</code> and indices <code>inds</code>,  whose elements are normally distributed random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L876-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.randomITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}" href="#ITensors.randomITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}"><code>ITensors.randomITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomITensor(::Type{ElT &lt;: Number}, inds::IndexSet)
randomITensor(::Type{ElT &lt;: Number}, inds::Index...)</code></pre><p>Construct an ITensor with type <code>ElT</code> and indices <code>inds</code>,  whose elements are normally distributed random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L857-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setelt-Tuple{IndexVal}" href="#ITensors.setelt-Tuple{IndexVal}"><code>ITensors.setelt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setelt(iv)</code></pre><p>Create an ITensor with all zeros except the specified value, which is set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L386-L391">source</a></section></article><h2 id="Sparse-constructors-1"><a class="docs-heading-anchor" href="#Sparse-constructors-1">Sparse constructors</a><a class="docs-heading-anchor-permalink" href="#Sparse-constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{IndexSet}" href="#ITensors.diagITensor-Tuple{IndexSet}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(is::IndexSet)
diagITensor(is::Index...)</code></pre><p>Make a sparse ITensor of element type Float64 with non-zero elements  only along the diagonal. Defaults to storing zeros along the diagonal. The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L321-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}" href="#ITensors.diagITensor-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(::Type{ElT}, is::IndexSet)
diagITensor(::Type{ElT}, is::Index...)</code></pre><p>Make a sparse ITensor of element type <code>ElT</code> with only elements along the diagonal stored. Defaults to having <code>zero(T)</code> along  the diagonal.</p><p>The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L282-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{Array{#s46,1} where #s46&lt;:Number,IndexSet}" href="#ITensors.diagITensor-Tuple{Array{#s46,1} where #s46&lt;:Number,IndexSet}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(v::Vector{T}, is::IndexSet)
diagITensor(v::Vector{T}, is::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in <code>v</code> and  the ITensor will have element type <code>float(T)</code>. The storage will have type <code>NDTensors.Diag</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L301-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{Number,IndexSet}" href="#ITensors.diagITensor-Tuple{Number,IndexSet}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(x::Number, is::IndexSet)
diagITensor(x::Number, is::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value <code>float(x)</code> and the ITensor will have element type <code>float(eltype(x))</code>. The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L333-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.delta-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}" href="#ITensors.delta-Tuple{Type{#s46} where #s46&lt;:Number,IndexSet}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delta(::Type{ElT &lt;: Number}, inds::IndexSet)
delta(::Type{ElT &lt;: Number}, inds::Index...)</code></pre><p>Make a uniform diagonal ITensor with all diagonal elements <code>one(ElT)</code>. Only a single diagonal element is stored.</p><p>This function has an alias <code>δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L352-L360">source</a></section></article><h2 id="Getting-and-setting-elements-1"><a class="docs-heading-anchor" href="#Getting-and-setting-elements-1">Getting and setting elements</a><a class="docs-heading-anchor-permalink" href="#Getting-and-setting-elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, ivs...)</code></pre><p>Get the specified element of the ITensor, using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = &quot;i&quot;)
A = ITensor(2.0, i, i&#39;)
A[i =&gt; 1, i&#39; =&gt; 2] # 2.0, same as: A[i&#39; =&gt; 2, i =&gt; 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L524-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N" href="#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, I::Int...)</code></pre><p>Get the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = &quot;i&quot;)
A = ITensor(2.0, i, i&#39;)
A[1, 2] # 2.0, same as: A[i =&gt; 1, i&#39; =&gt; 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L501-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, ivs...)</code></pre><p>Set the specified element of the ITensor using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = &quot;i&quot;)
A = ITensor(i, i&#39;)
A[i =&gt; 1, i&#39; =&gt; 2] = 1.0 # same as: A[i&#39; =&gt; 2, i =&gt; 1] = 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L567-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, I::Int...)</code></pre><p>Set the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = &quot;i&quot;)
A = ITensor(i, i&#39;)
A[1, 2] = 1.0 # same as: A[i =&gt; 1, i&#39; =&gt; 2] = 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L545-L557">source</a></section></article><h2 id="Properties-1"><a class="docs-heading-anchor" href="#Properties-1">Properties</a><a class="docs-heading-anchor-permalink" href="#Properties-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.NDTensors.inds-Tuple{ITensor}" href="#ITensors.NDTensors.inds-Tuple{ITensor}"><code>ITensors.NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inds(T::ITensor)</code></pre><p>Return the indices of the ITensor as an IndexSet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.NDTensors.ind-Tuple{ITensor,Int64}" href="#ITensors.NDTensors.ind-Tuple{ITensor,Int64}"><code>ITensors.NDTensors.ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ind(T::ITensor, i::Int)</code></pre><p>Get the Index of the ITensor along dimension i.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L52-L56">source</a></section></article><h2 id="Priming-and-tagging-1"><a class="docs-heading-anchor" href="#Priming-and-tagging-1">Priming and tagging</a><a class="docs-heading-anchor-permalink" href="#Priming-and-tagging-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prime(A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; ITensor

prime!(A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;)</code></pre><p>Increase the prime level of the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L711-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setprime(A::ITensor, plev::Int; &lt;keyword arguments&gt;) -&gt; ITensor

setprime!(A::ITensor, plev::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L721-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noprime(A::ITensor; &lt;keyword arguments&gt;) -&gt; ITensor

noprime!(A::ITensor; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor to zero.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L731-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.mapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapprime(A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;) -&gt; ITensor

mapprime!(A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor with prime level <code>plold</code> to <code>plnew</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L741-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapprime(A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;) -&gt; ITensor

swapprime!(A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor with prime level <code>pl1</code> to <code>pl2</code>, and those with prime level <code>pl2</code> to <code>pl1</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L751-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addtags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

addtags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Add the tags <code>ts</code> to the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L761-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">removetags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

removetags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Remove the tags <code>ts</code> from the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L771-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replacetags(A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; ITensor

replacetags!(A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;)</code></pre><p>Replace the tags <code>tsold</code> with <code>tsnew</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L791-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

settags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Set the tags of the indices of an ITensor to <code>ts</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L781-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swaptags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swaptags(A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; ITensor

swaptags!(A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;)</code></pre><p>Swap the tags <code>ts1</code> with <code>ts2</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L801-L809">source</a></section></article><h2 id="Index-Manipulations-1"><a class="docs-heading-anchor" href="#Index-Manipulations-1">Index Manipulations</a><a class="docs-heading-anchor-permalink" href="#Index-Manipulations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceind(A::ITensor, i1::Index, i2::Index) -&gt; ITensor

replaceind!(A::ITensor, i1::Index, i2::Index)</code></pre><p>Replace the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L811-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}" href="#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceinds(A::ITensor, inds1, inds2) -&gt; ITensor

replaceinds!(A::ITensor, inds1, inds2)</code></pre><p>Replace the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L821-L831">source</a></section></article><h2 id="Math-operations-1"><a class="docs-heading-anchor" href="#Math-operations-1">Math operations</a><a class="docs-heading-anchor-permalink" href="#Math-operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{ITensor,ITensor}" href="#Base.:*-Tuple{ITensor,ITensor}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(A::ITensor, B::ITensor)</code></pre><p>Contract ITensors A and B to obtain a new ITensor. This  contraction <code>*</code> operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L969-L979">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{ITensor,Any}" href="#Base.exp-Tuple{ITensor,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(A::ITensor, Lis::IndexSet; hermitian = false)</code></pre><p>Compute the exponential of the tensor <code>A</code> by treating it as a matrix <span>$A_{lr}$</span> with the left index <code>l</code> running over all indices in <code>Lis</code> and <code>r</code> running over all indices not in <code>Lis</code>. Must have <code>dim(Lis) == dim(inds(A))/dim(Lis)</code> for the exponentiation to be defined. When <code>ishermitian=true</code> the exponential of <code>Hermitian(A_{lr})</code> is computed internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L1030-L1039">source</a></section></article><h2 id="Decompositions-1"><a class="docs-heading-anchor" href="#Decompositions-1">Decompositions</a><a class="docs-heading-anchor-permalink" href="#Decompositions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}" href="#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svd(A::ITensor, inds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Singular value decomposition (SVD) of an ITensor <code>A</code>, computed by treating the &quot;left indices&quot; provided collectively as a row index, and the remaining &quot;right indices&quot; as a column index (matricization of a tensor).</p><p>The first three return arguments are <code>U</code>, <code>S</code>, and <code>V</code>, such that <code>A ≈ U * S * V</code>.</p><p>Whether or not the SVD performs a trunction depends on the keyword arguments provided. </p><p><strong>Arguments</strong></p><ul><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.</li><li><code>lefttags::String = &quot;Link,u&quot;</code>: set the tags of the Index shared by <code>U</code> and <code>S</code>.</li><li><code>righttags::String = &quot;Link,v&quot;</code>: set the tags of the Index shared by <code>S</code> and <code>V</code>.</li><li><code>alg::String = &quot;recursive&quot;</code>. Options:<ul><li><code>&quot;recursive&quot;</code> - ITensor&#39;s custom svd. Very reliable, but may be slow if high precision is needed. To get an <code>svd</code> of a matrix <code>A</code>, an eigendecomposition of <span>$A^{\dagger} A$</span> is used to compute <code>U</code> and then a <code>qr</code> of <span>$A^{\dagger} U$</span> is used to compute <code>V</code>. This is performed recursively to compute small singular values.</li><li><code>&quot;divide_and_conquer&quot;</code> - A divide-and-conquer algorithm. LAPACK&#39;s gesdd.</li><li><code>&quot;qr_iteration&quot;</code> - Typically slower but more accurate than <code>&quot;divide_and_conquer&quot;</code>. LAPACK&#39;s gesvd.</li></ul></li><li><code>use_absolute_cutoff::Bool = false</code>: set if all probability weights below the <code>cutoff</code> value should be discarded, rather than the sum of discarded weights.</li><li><code>use_relative_cutoff::Bool = true</code>: set if the singular values should be normalized for the sake of truncation.</li></ul><p>See also: <a href="ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>factorize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/decomp.jl#L26-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}" href="#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factorize(A::ITensor, Linds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Perform a factorization of <code>A</code> into ITensors <code>L</code> and <code>R</code> such that <code>A ≈ L * R</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ortho::String = &quot;left&quot;</code>: Choose orthogonality properties of the factorization.<ul><li><code>&quot;left&quot;</code>: the left factor <code>L</code> is an orthogonal basis such that <code>L * dag(prime(L, commonind(L,R))) ≈ I</code>. </li><li><code>&quot;right&quot;</code>: the right factor <code>R</code> forms an orthogonal basis. </li><li><code>&quot;none&quot;</code>, neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).</li></ul></li><li><code>which_decomp::Union{String, Nothing} = nothing</code>: choose what kind of decomposition is used. <ul><li><code>nothing</code>: choose the decomposition automatically based on the other arguments. For example, when <code>&quot;automatic&quot;</code> is chosen and <code>ortho = &quot;left&quot;</code> or <code>&quot;right&quot;</code>, <code>svd</code> or <code>eigen</code> is used depending on the provided cutoff (<code>eigen</code> is only used when the cutoff is greater than <code>1e-12</code>, since it has a lower precision).</li><li><code>&quot;svd&quot;</code>: <code>L = U</code> and <code>R = S * V</code> for <code>ortho = &quot;left&quot;</code>, <code>L = U * S</code> and <code>R = V</code> for <code>ortho = &quot;right&quot;</code>, and <code>L = U * sqrt.(S)</code> and <code>R = sqrt.(S) * V</code> for <code>ortho = &quot;none&quot;</code>. To control which <code>svd</code> algorithm is choose, use the <code>svd_alg</code> keyword argument. See the documentation for <code>svd</code> for the supported algorithms, which are the same as those accepted by the <code>alg</code> keyword argument.</li><li><code>&quot;eigen&quot;</code>: <code>L = U</code> and <span>$R = U^{\dagger} A$</span> where <code>U</code> is determined from the eigendecompositon <span>$A A^{\dagger} = U D U^{\dagger}$</span> for <code>ortho = &quot;left&quot;</code> (and vice versa for <code>ortho = &quot;right&quot;</code>). <code>&quot;eigen&quot;</code> is not supported for <code>ortho = &quot;none&quot;</code>.</li></ul></li></ul><p>In the future, other decompositions like QR, polar, cholesky, LU, etc. are expected to be supported.</p><p>For truncation arguments, see: <a href="ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>svd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/decomp.jl#L319-L337">source</a></section></article><h2 id="Operations-1"><a class="docs-heading-anchor" href="#Operations-1">Operations</a><a class="docs-heading-anchor-permalink" href="#Operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.permute-Tuple{ITensor,Any}" href="#ITensors.permute-Tuple{ITensor,Any}"><code>ITensors.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(T::ITensors, inds)
permute(T::ITensors, inds::Index...)</code></pre><p>Return a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8710224899fb5db25d251b7d48f79fd9edd0b868/src/itensor.jl#L929-L936">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="IndexSetType.html">« IndexSet</a><a class="docs-footer-nextpage" href="MPSandMPO.html">MPS and MPO »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 25 April 2020 22:19">Saturday 25 April 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
